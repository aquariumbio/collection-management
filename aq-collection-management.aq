{"config":{"title":"Collection_Management","description":"A group of libraries to assist with collections and using collections","copyright":"University of Washington","version":"0.0.1","authors":[{"name":"Cannon Mallory","affiliation":"University of Washington"},{"name":"Amy Cash","affilation":"","affiliation":"University of Washington"},{"name":"Justin Vrana","affilation":"","affiliation":"University of Washington"}],"maintainer":{"name":"Cannon Mallory","email":"malloc3@uw.edu"},"acknowledgements":[{"name":"Benjamin Keller","affilation":"","affiliation":"University of Washington"},{"name":"Devin Strickland","affilation":"","affiliation":"University of Washington"}],"github":{"user":"malloc3","repo":"aq-collection-management","organization":"klavinslab"},"keywords":null,"aquadoc_version":"1.0.0","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"sample_types":[],"object_types":[],"operation_type":{"name":"ExampleUses","category":"Collection Management","deployed":false,"on_the_fly":false,"field_types":[],"protocol":"# This is to show the basic uses of the Collection Management library\nneeds 'Collection_Management/CollectionDisplay'\nneeds 'Collection_Management/CollectionTransfer'\nneeds 'Collection_Management/CollectionActions'\nneeds 'Collection_Management/CollectionLocation'\n\nclass Protocol\n  include CollectionDisplay\n  include CollectionTransfer\n  include CollectionLocation\n  include CollectionActions\n\n\n  def main\n\n\n    #CollectionActions\n\n    #many basic actions can be done with a Collection using CollectionActions\n\n    # A new collection can easily be made and instructions given to retrieve and\n    # label the collection with one line.  By default instructions will be given\n    # however these instructions can be skipped if label_plate is false\n    new_collection = make_new_plate('96 Well Sample Plate', label_plate: true)\n\n    #We can set the location of an array of collections easily using\n    set_location([new_collection], \"My New Location\")\n\n    # If we want to see where all these locations are and diplay this to the tech\n    # We can use a short show block and utilize \"create_location_table\"\n    show do\n      title \"Here we display the location of our collection\"\n      table create_location_table([new_collection])\n    end\n\n    # We can then store the collections using \"store_items\"\n    # This will provide instructions for the storage of items as well as\n    # set their location if a location string is provided\n    # This either can be an array of items or an individual item\n    store_items(new_collection, location: 'Short Term Storage')\n\n    # Lastly we trash the collection (or a group of items) using 'trash_objects'\n    # This will create instructions for trashing the object and set its status to 'deleted'\n    # It will take either a single item or an array of items\n    trash_objects(new_collection)\n\n\n\n\n\n\n\n\n    # CollectionLocation\n    # ColelctionLocation is primarily for giving and managing locations of items inside of collections\n    #   It does not manage the physical location of the Collection its self (thats what CollectionActions\n    #   is for).\n\n    # To look at and deal with the locations of items in a collection we must first create and populate\n    # a collection with items.   There are nice methods that assist with this that will be described\n    # later but for now we will just fill the collection using standard Aquarium methods\n\n    # this time we will create a new collection but will not provide instructions to fetch\n    # and label the collection.  In this case this does exactly the same thing as \n    # Collection.new_collection('96 Well Sample Plate')\n    location_collection = make_new_plate('96 Well Sample Plate', label_plate: false)\n\n    array_of_samples = []\n\n    operations.each do |op|\n      array_of_samples += op.input_array('InputArray').each {|fv| fv.sample}\n    end\n    example_sample = array_of_samples.first\n\n    # This is a built in colleciton method that will add the array of samples to the collection\n    location_collection.add_samples(array_of_samples) #populates the colleciton with samples\n\n\n    # first if we want to find the location of a sample in the collection we can call\n    # collection.find(sample) this will return an array [row, column]\n    row_col_location = location_collection.find(example_sample)\n    show do \n      note \"#{row_col_location}\"\n    end\n\n    # similarly we could use get_obj_location(collection, object_to_find)\n    # You can pass this method either a single object or an array of objects\n    # if you pass a single object it will work exactly the same as .find\n    # however if an array of objects are passed the method will return a Hash\n    # with keys as the searched object and the values as the array of locations\n    returned_locations = get_obj_location(collection, array_of_samples)\n    show do\n      title \"The locations of many objects\"\n      returned_locations.each do |key, array_of_locations|\n        note \"The object #{key.id} is in locations #{array_of_locations}\"\n      end\n    end\n\n    # If you know that you will want the Alpha Numerical location when you search for an object\n    # you can use get_alpha_num_location.   This works exactly the same as get_obj_locations\n    # Except it will return alpha numerical locations and not coordinates\n    alpha_location = get_alpha_num_location(collection, array_of_samples)\n\n\n\n\n    # The functions above are useful but really dont really expand the standard methods very much\n    # The CollectionLocations library really helps out when dealing with locations listed in both\n    # the [row, column] format as well as the AlphaNumerical format (e.g. A1, B12)\n\n    # Two methods to help with conversion between Alpha Numerical location and coordinates are\n    # convert_location_to_coordinates and convert_coordinates_to_location wich do exactly as the name \n    # describes\n\n    # convert_location_to_coordinates will convert an alpha numerical string into rows and coordinates\n    coordinates = convert_location_to_coordinates('A1')\n\n    # convert_coordinates_to_location will conver a coordinate into a alpha numerical string\n    alpha_location = convert_coordinates_to_location([1,1])\n\n    show do\n      title \"Demonstration of convert_coordinates_to_location and convert_location_to_coordinates methods\"\n      note \"#{coordinate}\"\n      note \"#{alpha_location}\"\n    end\n\n\n\n    # A common need is to find the part at a certain location in a collection\n    # if we know the coordinate location of the part doin this is easy.  Simple put\n    # collection.part(row,location)\n    item = location_collection.part(1,1)\n\n    # However if we only know the Alpha Numerical Location then you can use\n    item = locate_part(location_collection, 'A1')\n\n\n    trash_objects(location_collection)\n\n    # CollectionDisplay\n    # One thing that is always important when writing protocols is displaying to the\n    # tech what they need to do.  To assist with this CollectionDisplay was developed.\n\n    # Before we get into the nitty gritty of CollectionDisplay a few ideas must be established\n    # first.\n    #\n    # Most methods must be passed a Collection and an 'RCX' list.  RCX list stands for a list of the\n    # format [[row, column, x], [row, column, x], ...]  where x is some extra information that affects \n    # what is displayed at the well (row, column).  Often x is just a string but in some case it can be\n    # more to help influence how it is displayed.\n\n    \n    #First we need to create a colleciton with some samples\n    display_collection = make_new_plate('96 Well Sample Plate', label_plate: false)\n    array_of_samples = []\n    operations.each do |op|\n      array_of_samples += op.input_array('InputArray').each {|fv| fv.sample}\n    end\n    example_sample = array_of_samples.first\n    display_collection.add_samples(array_of_samples)\n\n\n\n    # To show all filled slots simply put highlight_non_empty\n    #\n    # The check option sets the wells as \"checkable\"\n    # this forces the tech to click on each slot before they can click continue.\n    # in this case check is set to false\n    show do \n      title \"This is all the filled slots\"\n      table highlight_non_empty(display_collection, check: false)\n    end\n\n    # To show all empty slots simply put\n    show do\n      title \"This is all the empty slots\"\n      table highlight_empty(display_collection, check: false)\n    end\n\n    # The following two methods work the same as the the previous two\n    # The only difference is that they also show a string with the \n    # alpha numerical location\n    show do \n      title \"Showing the alpha numerical labels as well\"\n      note \"All the filled slots\"\n      table highlight_alpha_non_empty(display_collection, check: false)\n      note \"This is all the empty slots\"\n      table highlight_alpha_empty(display_collection, check: false)\n    end\n    \n    \n\n\n    # There are many ways to create an RCX list often a protocol will need a custom\n    # format depending on what information is to be displayed.  It will be up to you\n    # to make these custom RCX lists.  However there are a few basic methods that have been\n    # created that make standard/common RCX lists.\n\n    # One common desire is to display a collection and show the Alpha Numerical location\n    # of some subset of samples.  This can illustrate a specific number of wells and ensure\n    # there is a low chance of misunderstanding.  The following method makes an RCX list of teh\n    # form [[row, column, AlphaLocation], ...]\n    #\n    # This method takes the collection and a list of samples or items that you want displayed\n    # if a sample is in the collection multiple times it will create rcx components for each\n    # location\n    rcx_list = get_rcx_list(collection, array_of_samples)\n\n\n\n\n\n    \n\n    \n\n  end\n\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"library":{"name":"CollectionActions","category":"Collection Management","code_source":"# Cannon Mallory\n# malloc3@uw.edu\n#\n# Module for working with collections\n# These actions should involve the WHOLE plate not individual wells.\n# NOTE: The collection is doing the whole action\n\nneeds 'Standard Libs/ItemActions'\n\nmodule CollectionActions\n  include ItemActions\n\n  # Creates new collection.  Instructions to tech optional\n  #\n  # @param c_type [String] the collection type\n  # @param label_plate [Boolean] instructs tech to label if true\n  # @return working_plate [Collection]\n  def make_new_plate(c_type, label_plate: true)\n    working_plate = Collection.new_collection(c_type)\n    get_and_label_new_plate(working_plate) if label_plate\n    working_plate\n  end\n\n  # Makes an exact copy of the from collection.\n  # Will make the to_collection if needed\n  #\n  # @param from_collection [Collection]\n  # @param to_collection [Collection]\n  # @param label_plates [Boolean]\n  # @return to_Collection [Collection]\n  def exact_copy(from_collection, to_collection: nil, label_plates: false)\n    collection_type = from_collection.object_type\n    if to_collection.nil?\n      to_collection = make_new_plate(collection_type, label_plate: label_plates)\n    end\n    matrix = from_collection.matrix\n    to_collection.matrix = matrix\n    to_collection\n  end\n\n  # Makes the required number of collections and populates with samples\n  # returns an array of of collections created\n  #\n  # @param samples [Array\u003cFieldValue\u003e] or [Array\u003cSamples\u003e]\n  # @param collection_type [String] the type of collection that is to be made\n  # @param first_collection [Collection] optional a collection to start with\n  # @param add_column_wise [Boolean] default false add samples by column\n  # @param label_plates [Boolean] default false, provides instructions\n  # @return [Array\u003cCollection\u003e] array of collections created\n  def make_and_populate_collection(samples, collection_type: nil,\n                                   first_collection: nil,\n                                   add_column_wise: false,\n                                   label_plates: false)\n\n    if collection_type.nil? \u0026\u0026 first_collection.nil?\n      ProtocolError 'Either collection_type or first_collection must be given'\n    end\n\n    unless collection_type.nil? || first_collection.nil?\n      ProtocolError 'Both collection_type and first_collection cannot be given'\n    end\n\n    capacity = nil\n    if collection_type.nil?\n      collection_type = first_collection.object_type.name\n      capacity = first_collection.capacity\n      remaining_space = first_collection.get_empty.length\n      add_samples_to_collection(samples[0...remaining_space - 1],\n                                first_collection,\n                                label_plates: label_plates,\n                                add_column_wise: add_column_wise)\n      samples = samples.drop(remaining_space)\n    else\n      obj_type = ObjectType.find_by_name(collection_type)\n      capacity = obj_type.columns * obj_type.rows\n    end\n\n    collections = []\n    collections.push(first_collection) unless first_collection.nil?\n    grouped_samples = samples.in_groups_of(capacity, false)\n    grouped_samples.each do |sub_samples|\n      collection = make_new_plate(collection_type, label_plate: label_plates)\n      add_samples_to_collection(sub_samples, collection, \n                                add_column_wise: add_column_wise)\n      collections.push(collection)\n    end\n    collections\n  end\n\n  # Assigns samples to specific well locations\n  #\n  # @param samples [Array\u003cFieldValue\u003e] or [Array\u003cSamples\u003e]\n  # @param to_collection [Collection]\n  # @param add_row_wise [Boolean] default false, will add samples by column\n  # @raise if not enough space in collection\n  def add_samples_to_collection(samples, to_collection, add_column_wise: false)\n    samples.map! do |fv|\n      unless fv.is_a?(Sample)\n        fv = fv.sample\n      end\n      fv\n    end\n\n    slots_left = to_collection.get_empty.length\n    raise 'Not enough space in in collection' if samples.length \u003e slots_left\n\n    if add_column_wise\n      add_samples_column_wise(samples, to_collection)\n    else\n      to_collection.add_samples(samples)\n    end\n    to_collection\n  end\n\n  # Adds samples to the first slot in the first available column\n  # as opposed to column wise that the base version does.\n  #\n  # @param samples_to_add [Array\u003cSamples\u003e] an array of samples\n  # @param collection [Collection] the collection to include samples\n  def add_samples_column_wise(samples_to_add, collection)\n    col_matrix = collection.matrix\n    columns = col_matrix.first.size\n    rows = col_matrix.size\n    samples_to_add.each do |sample|\n      break_pattern = false\n      columns.times do |col|\n        rows.times do |row|\n          if collection.part(row, col).nil?\n            collection.set(row, col, sample)\n            break_pattern = true\n            break\n          end\n        end\n        break if break_pattern\n      end\n    end\n  end\n\n  # Instructions on getting and labeling new plate\n  #\n  # @param plate [Collection] the plate to be retrieved and labeled\n  def get_and_label_new_plate(plate)\n    show do\n      title 'Get and Label Working Plate'\n      note \"Get a \u003cb\u003e#{plate.object_type.name}\u003c/b\u003e and\n           label it ID: \u003cb\u003e#{plate.id}\u003c/b\u003e\"\n    end\n  end\n\n  # Associates field_values to corresponding samples in a collection\n  # TODO not sure multiples of samples is handled in the best way...\n  #\n  # @param field_values [Array\u003cField Values\u003e] array of field values\n  # @param collection [Collection] the destination collection\n  # replaced make_output_plate\n  def associate_field_values_to_plate(field_values, collection)\n    already_associated_parts = []\n    field_values.each do |fv|\n      r_c = nil\n      collection.find(fv.sample).each do |loc|\n        r_c = loc\n        break unless already_associated_parts.include?(loc)\n      end\n      r_c = collection.find(fv.sample).first\n      unless r_c.nil?\n        fv.set(collection: collection, row: r_c[0], column: r_c[1])\n      end\n    end\n  end\n  \n  # Provides instructions to cover plate\n  #\n  # @param collection [Collection]\n  # @param rc_list [Array\u003c[r,c]\u003e] specify certain wells to cover\n  def seal_plate(collection, rc_list: nil)\n    show do\n      title 'Seal Wells'\n      note \"Using an area seal carefully seal plate #{collection.id}\"\n      unless rc_list.nil?\n        warning 'ONLY seal the highlighted wells'\n        table highlight_collection_rc(collection, rc_list)\n      end\n    end\n  end\nend\n"}},{"library":{"name":"CollectionData","category":"Collection Management","code_source":"# CollectionData\n\nneeds 'Standard Libs/AssociationManagement'\n\n# for managing data associations of collections\n# and ensuring that samples/item data is handled correctly\nmodule CollectionData\n  include AssociationManagement\n  include PartProvenance\n\n  # Is this being used?\n  # Associates data to every part in a plate\n  #\n  # @param plate [Collection] the collection\n  # @param data [Anything] the data to be associated\n  def associate_to_all(plate:, data:, key:)\n    data_map = []\n    parts.each do |part|\n      loc = plate.find(part)\n      loc[2] = data\n      loc[3] = key\n      data_map.push(loc)\n    end\n    associate_value_key_to_parts(plate: plate, data_map: data_map)\n  end\n\n  # Creates table for the data associated with key\n  #\n  # @param collection [Collection] the plate being used\n  # @param keys [Array\u003cString\u003e] an array of keys that the data is\n  #        associated with.\n  # @return table of parts with data information\n\n  def display_all_data(collection, keys)\n    rc_list = []\n    parts = collection.parts\n    parts.each do |part|\n      rc_list += collection.find(part)\n    end\n    display_data(collection, rc_list, keys)\n  end\n\n  # Associates data in data_map to parts in plate.\n  #\n  # @param plate [Collection] the plate containing the Items\n  # @param data_map [Array\u003cArray\u003crow, column, value\u003e, ...\u003e] \n  #                                         determine where data goes\n  # @param key [String] the key that\n  def associate_value_to_parts(plate:, data_map:, key:)\n    data_map.each do |loc_val_array|\n      loc_val_array[3] = key\n    end\n    associate_value_key_to_parts(plate: plate, data_map: data_map)\n  end\n\n  # Creates a DataAssociation for each entry with Key :part_data and\n  # Value \"well\" (saved as DataAssociation.object)\n  # Each value is associated to its respective key\n  #\n  # @param plate [Collection] the plate that contains the parts (items)\n  # @param data_map [Array\u003cArray\u003cr,c, value, key\u003e, ...\u003e] data map of all parts\n  def associate_value_key_to_parts(plate:, data_map:)\n    data_map.each do |key_value_map|\n      part = plate.part(key_value_map[0], key_value_map[1])\n      data_value = key_value_map[2]\n      key = key_value_map[3]\n      associate_data(part, key.to_sym, data_value) unless part.nil?\n    end\n  end\n\n  # Adds data to list of coordinates\n  # If there is already a data value present, the new data value will\n  # either replace it, or be appended to it\n  # based on the value of the append boolean\n  #\n  # @param coordinates [Array\u003cRow(int), Column(int), Optional(String)] the\n  #       coordinate list to be modified\n  # @param data [String] string to be added to the list data\n  # @param append: [Boolean] default true.  Replace if false\n  def append_x_to_rcx(coordinates, data, append: true)\n    data = data.to_s\n    if coordinates[2].nil? || !append\n      coordinates[2] = data\n    else\n      coordinates[2] += ', ' + data\n    end\n    coordinates\n  end\n\n\n  # Creates an array of samples that are the same in two different Collections\n  #\n  # @param collection_a [Collection] a collection\n  # @param collection_b [Collection] a collection\n  # @return [Array\u003cSample\u003e]\n\n  def find_like_samples(collection_a, collection_b)\n    collection_a.parts.map!(\u0026:sample) \u0026 collection_b.parts.map!(\u0026:sample)\n  end\n\n\n  # Returns an array of parts in the Collection that match the right Sample\n  #\n  # @param collection [Collection] the Collection that the Item (part) is in\n  # @param sample [Sample] the Sample searched for\n\n  def parts_from_sample(collection, sample)\n    part_location = collection.find(sample)\n    parts = []\n    part_location.each do |coordinates|\n      parts.push(collection.part(coordinates[0], coordinates[1]))\n    end\n    parts\n  end\n\n\n  # Adds provenance history to to_object and from from_object\n  #\n  # @param from_obj [Item] object that provenance is coming from\n  # @param to_obj [Item] the object that provenance is going to\n  \n  def from_obj_to_obj_provenance(to_obj, from_obj)\n    raise \"Object #{to_obj.id} is not an item\" unless to_obj.is_a? Item\n    raise \"Object #{from_obj.id} is not an item\" unless from_obj.is_a? Item\n\n    from_obj_map = AssociationMap.new(from_obj)\n    to_obj_map = AssociationMap.new(to_obj)\n    add_provenance(from: from_obj, from_map: from_obj_map,\n                   to: to_obj, to_map: to_obj_map)\n    from_obj_map.save\n    to_obj_map.save\n  end\nend\n"}},{"library":{"name":"CollectionDisplay","category":"Collection Management","code_source":"# Justin Vrana\n#\n# modified by:\n# Cannon Mallory\n# malloc3@uw.edu\n#\n# Modifications include:\n# Optional Checkable boxes.  Additional Documentation\n\n# Methods for displaying information about collections\nmodule CollectionDisplay\n  # Highlights all non-empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_non_empty(collection, check: true, \u0026rc_block)\n    highlight_collection_rc(collection, collection.get_non_empty,\n                            check: check, \u0026rc_block)\n  end\n\n  # Highlights all empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_empty(collection, check: true, \u0026rc_block)\n    highlight_collection_rcx(collection, collection.get_empty,\n                            check: check, \u0026rc_block)\n  end\n\n  # Highlights all non-empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_alpha_non_empty(collection, check: true, \u0026rc_block)\n    rcx = collection.get_non_empty\n    rcx.each do |coor|\n      coor.push(get_alpha(coor.first + 1) + (coor[1] + 1).to_s)\n    end\n    highlight_alpha_rcx(collection, rcx,\n                       check: check, \u0026rc_block)\n  end\n\n  # Highlights all empty slots in collection\n  #\n  # @param collection [Collection] the collection\n  # @param check [Boolean] Optional weather cells should be Checkable\n  # @param \u0026rc_block [Block] Optional block to determine rc_list\n  # @return [Table]\n  def highlight_alpha_empty(collection, check: true, \u0026rc_block)\n    rcx = collection.get_empty\n    rcx.each do |coor|\n      coor.push(get_alpha(coor.first) + coor[1].to_s)\n    end\n    highlight_alpha_rc(collection, collection.get_empty,\n                       check: check, \u0026rc_block)\n  end\n\n  # Gets a list of the coordinates and alphanumeric locations\n  #\n  # @param collection [Collection] the collection that items are going to\n  # @param samples [The samples that locations are wanted from]\n  #\n  # @return [Array\u003cArray\u003crow, column, location\u003e] Coordinates and\n  #      locations in same order as sample array\n  def get_rcx_list(collection, samples)\n    coordinates_and_data = []\n    samples.each do |sample|\n      sample_coordinates = get_items_coordinates(collection, [sample])\n      sample_locations = get_alpha_num_location(collection, sample)\n\n      sample_coordinates.each do |coordinates|\n        raise \"sample locations #{sample_locations[sample].class}\"\n        coordinates.push(sample_locations[sample]) # [0,0,A1]\n        coordinates_and_data.push(coordinates)\n      end\n    end\n    coordinates_and_data\n  end\n\n  # Highlights all cells listed in rc_list (CHANGED NAME)\n  #\n  # @param collection [Collection] the collection which should be highlighted\n  # @param rc_list [Array] array of rc [[row,col],...]\n  #                       row = int\n  #                       col = int4\n  # @param check [Boolean] Optional whether cells should be Checkable\n  # @param \u0026rc_block [Block] to determine rc list\n  # @return [Table]\n  def highlight_collection_rc(collection, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map { |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, '']\n    }\n    highlight_collection_rcx(collection, rcx_list, check: check)\n  end\n\n  # Highlights all cells in ROW/COLUMN/X\n  #\n  #\n  # @param collection [Collection] the collection\n  # @param rcx_list [Array] array of [[row, colum, x],...]\n  #     row = int\n  #     col = int\n  #     x = string\n  # @return [Table]\n  def highlight_collection_rcx(collection, rcx_list, check: true)\n    rows, columns = collection.dimensions\n    table = create_collection_table(rows: rows, columns: columns, col_id: collection.id)\n    highlight_rcx(table, rcx_list, check: check)\n  end\n\n  # Makes an alpha numerical display of collection wells listed in rc_list\n  #\n  # @param collection [Collection] the collection\n  # @param rc_list [Array] Array of rows and columns [[row,col],...]\n  # @param check [Boolean] Default True weather cells are checkable\n  # @param \u0026rc_block [Block] Optional tbd\n  def highlight_alpha_rc(collection, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map do |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, get_alpha(r+1) + (c+1).to_s]\n    end\n    highlight_alpha_rcx(collection, rcx_list, check: check)\n  end\n\n  # Makes an alpha numerical display of collection wells listed in rcx_list\n  #\n  # @param collection [Collection] the collection\n  # @param rc_list [Array] Array of rows and columns [[row,col,x],...]\n  #         row,column are int, x is string\n  # @param check [Boolean] Default True weather cells are checkable\n  # @param \u0026rc_block [Block] Optional tbd\n  def highlight_alpha_rcx(collection, rcx_list, check: true)\n    rows, columns = collection.dimensions\n    tbl = create_collection_table(rows: rows, columns: columns, col_id: collection.id)\n    rcx_list.each do |r, c, x|\n      highlight_cell(tbl, r, c, x, check: check)\n    end\n    tbl\n  end\n\n  # Creates a table with the same dimensions as the input collection\n  #\n  # @param collection [Collection] the collection to be represented by the table\n  # @param add_headers [Boolean] optional True\n  # @return tab [Table] a table to be displayed\n  def create_collection_table(rows:, columns:, col_id:)\n    col_id = col_id.to_s.chars\n    rows = rows + 1\n    size = rows * columns\n    slots = (1..size + rows + columns + 1).to_a\n    tab = slots.each_slice(columns + 1).map do |row|\n      row.map do\n        { class: 'td-empty-slot' }\n      end\n    end\n\n    #labels = Array(1...size + 1)\n    tab.each_with_index do |row, row_idx|\n      row.each_with_index do |col, col_idx|\n        if row_idx == 0\n          if col_idx == 0\n            content = 'ID:'\n          else\n            content = col_id[col_idx-1]\n          end\n          col[:content] = \n            \"\u003cfont color = 'black'\u003e \u003cb\u003e#{content}\u003c/b\u003e \u003c/font\u003e\"\n        elsif row_idx == 1\n          col[:content] = \n            \"\u003cfont color = 'blue'\u003e \u003cb\u003e#{col_idx}\u003c/b\u003e \u003c/font\u003e\"\n        elsif col_idx.zero?\n          col[:content] = \n            \"\u003cfont color = 'blue' \u003cb\u003e#{get_alpha(row_idx-1)}\u003c/b\u003e \u003c/font\u003e\"\n        else\n          col[:content] = '-'\n        end\n      end\n    end\n    tab[1].first[:content] = '\u0026#129514'\n    tab\n  end\n\n  # converts numbers to alphabetical values (eg 1-\u003eA 27-AA etc)\n  #\n  # @param num [Integer] the integer to be converted\n  def get_alpha(num)\n    alpha26 = ('A'...'AA').to_a\n    return \"\" if num \u003c 1\n    string = \"\"\n    loop do\n      num, r = (num-1).divmod(26)\n      string.prepend(alpha26[r])\n      break if num.zero?\n    end\n    string\n  end\n\n  # Highlights a specific location in a table (TODO TABLE CLASS)\n  #\n  # @param tbl [Table] the table which parts are being highlighted\n  # @param row [Integer] the row\n  # @param col [Integer] the column\n  # @param id [String] what will be printed in the table\n  #                    (TODO EMPTY STRING/DON'T REPLACE CONTENT)\n  # @param check [Boolean] optional determines if cell is checkable or not\n  def highlight_cell(tbl, row, col, id, check: true)\n    tbl[row + 2][col + 1] = { content: id, class: 'td-filled-slot', check: check }\n  end\n\n  # Highlights all cells in ROW/COLUMN/X  (TODO TABLE CLASS)\n  # X can be any string that is to be displayed in cell\n  #\n  # @param table [table] the table with cells to be highlighted\n  # @param rcx_list [array] array of [[row, column, x],...]\n  #     row = int\n  #     col = int\n  #     x = string\n  # @return [table]\n  def highlight_rcx(table, rcx_list, check: true)\n    rcx_list.each do |rcx|\n      rcx.push(check)\n    end\n    highlight_rcx_check(table, rcx_list)\n    table\n  end\n\n  # Highlights all cells in ROW/COLUMN/X  (TODO TABLE CLASS)\n  # X can be any string that is to be displayed in cell\n  #\n  # @param table [Table] the table with cells to be highlighted\n  # @param rcx_check_list [Array] array of [[row, column, data, check],...]\n  # @return [Table]\n  def highlight_rcx_check(table, rcx_check_list)\n    rcx_check_list.each do |row, column, data, check|\n      highlight_cell(table, row, column, data, check: check)\n    end\n    table\n  end\n\n  # TODO: TABLE LIB\n  # Highlights all cells listed in rc_list\n  #\n  # @param collection [Collection] the collection which should be highlighted\n  # @param rc_list [Array] array of rc [[row,col],...]\n  #                       row = int\n  #                       col = int\n  # @param check [Boolean] true if cells should be Checkable\n  # @param \u0026rc_block [Block] to determine rc list\n  # @return [Table]\n  def highlight_rc(table, rc_list, check: true, \u0026_rc_block)\n    rcx_list = rc_list.map do |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, \"\"]\n    end\n    highlight_rcx(table, rcx_list, check: check)\n  end\n\n  # Highlights all slots in all collections in operation list\n  #\n  # @param ops [OperationList] Operation list\n  # @param id_block [Block] Optional Unknown\n  # @param check [Boolean] true if cells should be Checkable\n  # @param \u0026fv_block [Block] Optional Unknown\n  # @return [Table]\n  def highlight_collection(ops, id_block: nil, check: true, \u0026fv_block)\n    g = ops.group_by { |op| fv_block.call(op).collection }\n    tables = g.map do |collection, grouped_ops|\n      rcx_list = grouped_ops.map do |op|\n        fv = fv_block.call(op)\n        id = id_block.call(op) if id_block\n        id ||= fv.sample.id\n        [fv.row, fv.column, id]\n      end\n      tbl = highlight_collection_rcx(collection, rcx_list, check: check)\n      [collection, tbl]\n    end\n    tables\n  end\n\n  # TODO: write highlight heat map method for table\n  # Creates table illustrating data associated with keys\n  #  for each part noted in rc_list\n  #\n  # @param collection [Collection] the collection\n  # @param keys [Array\u003cString\u003e] an array of all keys that point to desired data\n  # @param rc_list [Array\u003cArray\u003crow, col\u003e...\u003e] optional array of locations\n  #        if not given will display all non_empty\n  # @return table of parts with data information\n  def display_data(collection, keys, rc_list: nil)\n    if rc_list.nil?\n      rc_list = collection.get_non_empty\n    end\n    rcx_array = []\n    rc_list.each do |loc|\n      data_string = ''\n      keys.each_with_index do |key, idx|\n        part = collection.part(loc[0], loc[1])\n        data = get_associated_data(part, key).to_s\n        unless data.nil?\n          data_string += ', ' unless idx.zero?\n          data_string += data\n        end\n      end\n      loc.push(data_string)\n      rcx_array.push(loc)\n    end\n    highlight_collection_rcx(collection, rcx_array, check: false)\n  end\n\n  # Displays all sample id's\n  #\n  # @param collection [Collection] the collection\n  # @param rc_list [Array\u003cr,c,\u003e] optional if not then all existing parts\n  # @param check [Boolean]\n  # @return table\n  def display_sample_id(collection, rc_list: nil, check: false, opts: {})\n    rc_list = collection.get_non_empty if rc_list.nil?\n    rcx_list = []\n    rc_list.each do |r,c|\n      part = collection.part(r, c)\n\n      rcx_list.push([r, c, part.id]); next if opts[:part_id]\n\n      rcx_list.push([r, c, part.sample.id])\n    end\n    highlight_collection_rcx(collection, rcx_list, check: check)\n  end\nend\n"}},{"library":{"name":"CollectionLocation","category":"Collection Management","code_source":"# frozen_string_literal: true\n\n# Cannon Mallory\n# malloc3@uw.edu\n#\n# Methods to facilitate sample management within collections\nmodule CollectionLocation\n  ALPHA26 = ('A'...'Z').to_a\n\n  # Gets the location string of a sample in a collection\n  #\n  # @param collection [Collection] the collection containing the sample\n  # @param sample [Sample] the Sample that you want to locate\n  # @return [Hash{sample: location}] the Alpha Numeric location(s) e.g. A1, A2\n  def get_alpha_num_location(collection, items)\n    items = [items] unless items.is_a?(Array)\n\n    hash_of_samples = {}\n    items.each do |sample|\n      coordinates = collection.find(sample)\n      alpha_num_locations = []\n      coordinates.each do |coordinate_set|\n        alpha_num_locations \u003c\u003c convert_coordinates_to_location(coordinate_set)\n      end\n      alpha_num_locations.join(',')\n      hash_of_samples[sample] = alpha_num_locations\n    end\n    hash_of_samples\n  end\n\n  # Converts an array of coordinates to alpha numerical locations\n  #\n  # @param coordinates [Array\u003crow,column\u003e] set of coordinates\n  # @return [String] alpha numerical location\n  def convert_coordinates_to_location(coordinates)\n    ALPHA26[coordinates[0]] + (coordinates[1] + 1).to_s\n  end\n\n  # Converts alpha numerical location to an Array of coordinates\n  #\n  # @param alpha [String] alpha numerical location\n  # @return [Array\u003cr,c\u003e] array of row and column\n  def convert_location_to_coordinates(alpha)\n    alpha_characters = ''\n    alpha.length.times do |idx|\n      char = alpha[idx, idx+1]\n      alpha_characters += char unless float(char).nil?\n    end\n    row = ALPHA26.find_index(alpha_characters)\n    column = alpha[1..-1].to_i - 1\n    [row, column]\n  end\n\n  # Finds the location coordinates of an multiple items/samples\n  #\n  # @param collection [Collection] the Collection containing the Item or Sample\n  # @param items [Array\u003cobjects\u003e] Item, Part, or Sample to be found\n  # @return [Hash{sample: [row, column]}] \n  def get_items_coordinates(collection, items)\n    hash_of_locations = {}\n    items.each do |item|\n      hash_of_locations[item] = collection.find(item)\n    end\n    hash_of_locations\n  end\n\n  # Finds a part from an alpha numerical string location(e.g. A1, B1)\n  #  TODO Move to krill\n  #\n  # @param collection [Collection] the collection that contains the part\n  # @param location [String] the location of the part within the collection\n  # @return part [Item] the item at the given location\n  def get_part(collection, location)\n    row, column = convert_location_to_coordinates(location)\n    collection.part(row, column)\n  end\nend\n"}},{"library":{"name":"CollectionTransfer","category":"Collection Management","code_source":"# Cannon Mallory\n# malloc3@uw.edu\n#\n# Methods for transferring items into and out of collections\n\nneeds 'Standard Libs/Units'\nneeds 'Standard Libs/AssociationManagement'\nneeds 'Collection Management/CollectionLocation'\nneeds 'Collection Management/CollectionData'\n\nmodule CollectionTransfer\n  include Units\n  include AssociationManagement\n  include CollectionLocation\n  include CollectionData\n\n  VOL_TRANSFER = 'Volume Transferred'.to_sym\n\n  def to_association_map(collection:, item:)\n    association_map = []\n    locations = collection.find(item)\n    locations.each do |loc|\n      association_map.push( { to_loc: loc } )\n    end\n    association_map\n  end\n\n  def from_association_map(collection:, item:)\n    association_map = []\n    locations = collection.find(item)\n    locations.each do |loc|\n      association_map.push( { from_loc: loc } )\n    end\n    association_map\n  end\n\n  # Direction to use multichannel pipettor to pipet from an item\n  # into a collection\n  #\n  # @param to_collection [Collection]\n  # @param source [String] the source of the media etc\n  # @param volume [Volume] volume class volume being transferred\n  # @param association_map [Array\u003c{ to_loc: [row,col] }\u003e] all the\n  #        coordinate of where stuff is to go\n  def multichannel_item_to_collection(to_collection:,\n                                      source:,\n                                      volume:,\n                                      association_map:)\n    pipettor = get_multi_channel_pipettor(volume: volume)\n    channels = pipettor.channels\n    association_map.each_slice(channels).each do |rc_slice|\n      pipet_into_collection(to_collection: to_collection,\n                            source: source,\n                            pipettor: pipettor,\n                            volume: volume,\n                            association_map: rc_slice)\n    end\n  end\n\n  # Direction to use single channel pipettor to pipet from an item\n  # into a collection\n  #\n  # @param to_collection [Collection]\n  # @param source [String] the source of the media etc\n  # @param volume [Volume] volume class volume being transferred\n  # @param association_map [Array\u003c{ to_loc: [row,col] }\u003e] all the\n  #        coordinate of where stuff is to go\n  def single_channel_item_to_collection(to_collection:,\n                                        source:,\n                                        volume:,\n                                        association_map:)\n    pipettor = get_single_channel_pipettor(volume: volume)\n    pipet_into_collection(to_collection: to_collection,\n                          source: source,\n                          volume: volume,\n                          association_map: association_map,\n                          pipettor: pipettor)\n  end\n\n  # Direction to use single channel pipettor to pipet from\n  # a collection into a collection\n  #\n  # @param to_collection [Collection]\n  # @param from_collection [Collection]\n  # @param volume [Volume] volume class volume being transferred\n  # @param association_map [Array\u003c{ to_loc: [row,col], from_loc: {row, col} }\u003e]\n  #     all the coordinate of where parts are\n  def single_channel_collection_to_collection(to_collection:,\n                                              from_collection:,\n                                              volume:,\n                                              association_map:)\n    pipettor = get_single_channel_pipettor(volume)\n    association_map.each do |loc_hash|\n      pipet_collection_to_collection(to_collection: to_collection,\n                                     from_collection: from_collection,\n                                     pipettor: pipettor,\n                                     volume: volume,\n                                     association_map: [loc_hash])\n    end\n  end\n\n  # Direction to use single channel pipettor to pipet from\n  # a collection into a collection\n  #\n  # @param to_collection [Collection]\n  # @param from_collection [Collection]\n  # @param volume [Volume] volume class volume being transferred\n  # @param association_map [Array\u003c{ to_loc: [row,col], from_loc: {row, col} }\u003e]\n  #     all the coordinate of where parts are\n  def multichannel_collection_to_collection(to_collection:,\n                                            from_collection:,\n                                            volume:,\n                                            association_map:)\n    pipettor = get_multichannel_pipettor(volume)\n    association_map.slice(pipettor.channels).each do |map_slice|\n      pipet_collection_to_collection(to_collection: to_collection,\n                                     from_collection: from_collection,\n                                     pipettor: pipettor,\n                                     volume: volume,\n                                     association_map: map_slice)\n    end\n  end\n\n  # Directions to use pipet to transfer from a collection to a collection\n  #\n  # @param to_collection [Collection]\n  # @param from_collection [Collection]\n  # @param volume [Volume] volume class volume being transferred\n  # @param association_map [Array\u003c{ to_loc: [row,col], from_loc: {row, col} }\u003e]\n  #     all the coordinate of where parts are\n  # @param pipettor [Pipettor] the pipettor to be used\n  def pipet_collection_to_collection(to_collection:,\n                                     from_collection:,\n                                     pipettor:,\n                                     volume:,\n                                     association_map:)\n    to_rc_list = []\n    from_rc_list = []\n    association_map.each do |loc_hash|\n      to_rc_list.push(loc_hash[:to_loc])\n      from_rc_list.push(loc_hash[:from_loc])\n    end\n    show do\n      title 'Pipet from Collection to Collection'\n      note pipettor.pipet(volume: volume,\n                          source: to_collection.id,\n                          destination: \"\u003cb\u003e#{to_collection.id}\u003c/b\u003e as noted below}\")\n      table highlight_collection_rc(to_collection, to_rc_list) { |r, c|\n        convert_coordinates_to_location([r, c])\n      }\n      table highlight_collection_rc(from_collection, from_rc_list) { |r, c|\n        convert_coordinates_to_location([r, c])\n      }\n    end\n  end\n\n  def pipet_into_collection(to_collection:,\n                            source:,\n                            pipettor:,\n                            volume:,\n                            association_map:)\n    rc_list = association_map.map { |hash| hash[:to_loc] }\n    show do\n      title \"Pipet from #{source} to Collection\"\n      note pipettor.pipet(volume: volume,\n                          source: source,\n                          destination: \"\u003cb\u003e#{to_collection.id}\u003c/b\u003e noted below\")\n      table highlight_collection_rc(to_collection, rc_list) { |r, c|\n        convert_coordinates_to_location([r, c])\n      }\n    end\n  end\n\n  # Instructions to tech to relabel plate\n  #\n  # @param from_collection [Collection]\n  # @param to_collection [Collection]\n  def relabel_plate(from_collection:, to_collection:)\n    show do\n      title 'Rename Plate'\n      note \"Relabel plate \u003cb\u003e#{from_collection.id}\u003c/b\u003e with\n                        \u003cb\u003e#{to_collection.id}\u003c/b\u003e\"\n    end\n  end\n\n  # Transfers items from one collection to another per the association map\n  #\n  # @param from_collection [Collection]\n  # @param to_collection [Collection]\n  # @param association_map [Array\u003c{ to_loc: [r,c], from_loc: [r,c] }]\n  # @param transfer_vol [{qty: int, units: string}]\n  def transfer_from_collection_to_collection(from_collection:,\n                                             to_collection:,\n                                             association_map:,\n                                             transfer_vol: nil)\n    association_map.each do |loc_hash|\n      to_loc = loc_hash[:to_loc]\n      from_loc = loc_hash[:from_loc]\n\n      from_part = from_collection.part(from_loc[0], from_loc[1])\n      to_collection.set(to_loc[0], to_loc[1], from_part)\n    end\n    associate_transfer_collection_to_collection(from_collection: from_collection,\n                                                to_collection: to_collection,\n                                                association_map: association_map,\n                                                transfer_vol: transfer_vol)\n  end\n\n  # Transfers from item to well in collection\n  #\n  # @param from_item [item]\n  # @param to_collection [Collection]\n  # @param association_map [Array\u003c{ to_loc: [r,c], from_loc: [r,c] }]\n  # @param transfer_vol [{qty: int, units: string}]\n  def transfer_from_item_to_collection(from_item:,\n                                       to_collection:,\n                                       association_map:,\n                                       transfer_vol: nil)\n    association_map.each do |loc_hash|\n      to_loc = loc_hash[:to_loc]\n      to_collection.set(to_loc[0], to_loc[1], from_item)\n    end\n    associate_transfer_item_to_collection(from_item: from_item,\n                                          to_collection: to_collection,\n                                          association_map: association_map,\n                                          transfer_vol: transfer_vol)\n  end\n\n  # Associates/adds provenance for a transfer from a collection to\n  # a collection.   It does NOT replace the item in the 'to_collection'\n  #\n  # @param from_collection [Collection]\n  # @param to_collection [Collection]\n  # @param association_map [Array\u003c{ to_loc: [r,c], from_loc: [r,c] }]\n  # @param transfer_vol [{qty: int, units: string}]\n  def associate_transfer_collection_to_collection(from_collection:,\n                                                  to_collection:,\n                                                  association_map:,\n                                                  transfer_vol: nil)\n    association_map.each do |loc_hash|\n      from_part = from_collection.part(loc_hash[:from_loc][0],\n                                       loc_hash[:from_loc][1])\n      to_part = to_collection.part(loc_hash[:to_loc][0],\n                                   loc_hash[:to_loc][1])\n      unless transfer_vol.nil?\n        associate_transfer_vol(transfer_vol, VOL_TRANSFER, to_part: to_part,\n                                                           from_part: from_part)\n      end\n      from_obj_to_obj_provenance(to_part, from_part)\n    end\n  end\n\n  # Associates/adds provenance for a transfer from an item to\n  # a collection.   It does NOT replace the item in the 'to_collection'\n  #\n  # @param from_Item [item]\n  # @param to_collection [Collection]\n  # @param association_map [Array\u003c{ to_loc: [r,c], from_loc: [r,c] }]\n  # @param transfer_vol [{qty: int, units: string}]\n  def associate_transfer_item_to_collection(from_item:,\n                                            to_collection:,\n                                            association_map:,\n                                            transfer_vol: nil)\n    association_map.each do |loc_hash|\n      to_part = to_collection.part(loc_hash[:to_loc][0],\n                                   loc_hash[:to_loc][1])\n      unless transfer_vol.nil?\n        associate_transfer_vol(transfer_vol, VOL_TRANSFER, to_part: to_part,\n                                                           from_part: from_item)\n      end\n      from_obj_to_obj_provenance(to_part, from_item)\n    end\n  end\n\n  # Associates/adds provenance for a transfer from a collection to\n  # an item.\n  #\n  # @param from_collection [Collection]\n  # @param to_item [item]\n  # @param association_map [Array\u003c{ to_loc: [r,c], from_loc: [r,c] }]\n  # @param transfer_vol [{qty: int, units: string}]\n  def associate_transfer_collection_to_item(from_collection:,\n                                            to_item:,\n                                            association_map:,\n                                            transfer_vol: nil)\n    association_map.each do |loc_hash|\n      from_part = from_collection.part(loc_hash[:from_loc][0],\n                                       loc_hash[:from_loc][1])\n      unless transfer_vol.nil?\n        associate_transfer_vol(transfer_vol, VOL_TRANSFER, to_part: to_item,\n                                                           from_part: from_part)\n      end\n      from_obj_to_obj_provenance(to_item, from_part)\n    end\n  end\n\n  # Records the volume transferred\n  #\n  # @param transfer_vol [{qty: int, units: string}]\n  # @param to_part: part that is being transferred to\n  # @param from_part: part that is being transferred from\n  def associate_transfer_vol(vol, key, to_part:, from_part:)\n    vol_transfer_array = get_associated_data(to_part, key)\n    vol_transfer_array = [] if vol_transfer_array.nil?\n    vol_transfer_array.push([from_part.id, vol])\n    associate_data(to_part, key, vol_transfer_array)\n  end\n\n  # Creates a one to one association map\n  #\n  # @param to_collection [Collection] the to collection\n  # @param from_collection [Collection] the from collection\n  def one_to_one_association_map(to_collection:, from_collection: nil)\n    rows, cols = to_collection.dimensions\n    association_map = []\n    rows.times do |row|\n      cols.times do |col|\n        next unless from_collection.nil? || !from_collection.part(row, col).nil?\n\n        loc = [row, col]\n        association_map.push({ to_loc: loc, from_loc: loc })\n      end\n    end\n    association_map\n  end\nend\n"}}]}